* 기본개념을 확실히 다져야한단 생각이 들어 오늘부터 java책을 다시 공부하면서 개념 정리하기로.
* java를 끝낸 후 2,3회독은 스스로 하고, 후부터는 spring에 대해서 다시 공부하고 기록.

### Java의 특징
* 이식성이 높은 언어다.   
: 자바 언어로 개발된 프로그램은 소스 파일을 수정하지않아도 자바 실행 환경(JRE)이 설치되어 있는 모든 운영체제에서 실행 가능하다.   
* 객체 지향 언어다   
: 부품에 해당하는 객체들을 먼저 만들고 하나씩 조립 및 연결해서 전체 프로그램을 완성하는 기법-> 객체 지향 프로그래밍. 여기서 클래스는 설계도. 이 클래스로 객체를 만들고 객체들을 연결해서 프로그램을 만들어 낸다.   
* 함수적 스타일 코딩을 지원한다.   
: 대용량 데이터의 병렬 처리,이벤트 지향 프로그래밍을 위해 적합하다. 이를 위해 자바8부터 람다식을 지원한다.   
* 메모리를 자동으로 관리한다.   
: 개발자가 직접 메모리에 접근할 수 없도록 설계되어있으머, 메모리는 자바가 직접 관리-> Garbage Collector. 자동으로 사용하지 않는 객체를 제거시켜준다.    
* 다양한 애플리케이션을 개발할 수 있다.   
: 개발도구와 API를 묶어서 에디션 형태로 정의    
> Java SE -> JVM을 비롯해서 개발에 필수적인 도구와 라이브러리 API를 정의한다. 자바 프로그램을 개발하고 실행하기 위해서는 반드시 Java SE 구현체인 자바 개발 키트(JDK)를 설치해야한다.   
> Java EE -> 분산 환경(네트워크,인터넷)에서 서버용 애플리케이션을 개발하기위한 도구 및 라이브러리 API정의.   
* 멀티스레드를 쉽게 구현할 수 있다.   
: 하나의 프로그램이 여러가지 작업을 처리해야 할 경우와 대용량 작업을 빨리 처리하기 위해 병렬 처리를 하려면 멀티 스레드 프로그래밍이 필요하다. 자바는 스레드 생성 및 제어와 관련된 라이브러리API를 제공하고 있기 때문에 
운영체제 상관없이 멀티 스레드를 쉽게 구현할 수 있다.
* 동적 로딩을 지원한다. (로딩 -> 클래스파일을 바이트 코드로 읽어 메모리로 가져오는 과정)   
( 바이트 코드 : 가상 컴퓨터에서 돌아가는 실행 프로그램을 위한 이진 표현법)      
: 자바는 객체가 필요한 시점에 클래스를 동적로딩해서 객체를 생성한다. 또 개발 완료 후에 유지보수가 발생 하더라도 해당 클래스만 수정하면 되므로 전체 애플리케이션을 다시 컴파일할 필요가 없다.
-> 유지보수를 쉽고 빠르게 진행할 수 있다.   

### JVM
* 자바 프로그램은 기계어가 아닌 바이트 코드이기 때문에 중계를 해줘야한다. -> JVM이 해줌.
* 순서 : 소스 파일(.java) -> 컴파일러(javac)로 컴파일 -> 바이트 코드 파일이 생성됨(.class) -> JVM 구동 명령어에 의해 해석되고 운영체제에 맞게 기계어로 번역 -> 실행   
* 어디서든 실행가능하지만 JVM을 거쳐야하므로 기계어보다는 속도가 느리다.   

### 변수
* 변수 : 하나의 값을 저장할 수 있는 메모리 공간이다. 한 가지 타입의 값만 저장할 수 있다.   
* 같은 타입의 변수는 콤마를 이용해서 한꺼번에 선언할 수도 있다.   
* 변수 이름은 메모리 주소에 붙여진 이름이다. 변수의 이름을 통해서 메모리 주소에 접근한다.   
> 변수 이름 작성 규칙   
>  숫자로 시작할 수 없다.($,_ 이거나 문자로 시작)   
>  대소문자가 구분된다.   
>  첫 문자는 영어 소문자로 시작하되 다른 단어가 붙을 경우 첫 문자를 대문자로 한다.   
>  예약어는 사용할 수 없다.

* 변수를 선언하고 처음 값을 저장할 경우 이 값을 초기값이라고 한다. 초기값을 줌 -> 초기화   
* 직접 입력된 값 -> 리터럴   
> 정수 리터럴 -> byte,char,short,int,long   
> 실수 리터럴 -> float,double   
> 문자 리터럴 -> char   
> 문자열 리터럴 -> String   
> 논리 리터럴 -> boolean   
* 변수는 중괄호 블록 내에서 선언되고 사용된다. 메소드 블록 내에서 선언된 변수를 로컬 변수라고 부른다. 로컬 변수는 메소드 실행이 끝나면 메모리에서 자동으로 없어진다.   

#### 데이터 타입   
* 기본(primitive) 타입 : 정수,실수,문자,논리 리터럴을 직접 저장하는 타입.
> 정수 타입 : byte,char(음수값을 가질 수 없음),short,int(기본),long(수치가 큰 데이터를 다루는 프로그램에서는 필수적으로 사용)   
> 실수 타입 : float,double(기본)   
> 논리 타입 : boolean   
* long -> 정수값뒤에 L을 붙여줌.   
* 실수 타입은 소수점이 있는 데이터를 저장할 수 있는 타입. float 보다 double이 더 정밀한 값을 저장할 수 있다.   
* float -> 소수점이 있는 경우 끝에 f를 붙여야함.

#### 타입 변환
* 작은 크기의 타입은 자동으로 큰 크기의 타입으로 변환된다.(손실 없이 그대로 보존)   
> 주의 : cha는 2byte를 가지지만 음수가 저장될 수 없다. -> byte타입을 char 타입으로 자동 변환시킬 수 없다.
* 강제 타입 변환 : 큰 크기의 타입을 작은 타입으로 변환 시킬 때. (Casting)   
* 실수 타입은 정수 타입으로 자동 변환되지 않기 때문에 강제 타입 변환을 사용해야하는데 이 때 소수점 이하 부분은 버려지고 정수 부분만 저장된다.   
* 연산식에서는 두 피연산자 중 크기가 큰 타입으로 자동 변환된 후 연산을 수행한다.
* 정수 연산일 경우 피연산자를 4byte단위로 저장하기 때문에 int타입을 기본으로 한다. -> 4byte보다 작은 타입(byte,char,short)은 int타입으로 변환된 후 연산이 수행된다.   

### 연산자
* 우선순위
> 증감,부호,비트,논리 - 산술(*, /, %) - 쉬프트 - 비교 - 논리(& - ^ - | - && - ||) - 조건 - 대입   
* 오버플로우 : 산술 타입으로 표현할 수 없는 값이 산출되었을 경우 오버플로우가 발생하고 쓰레기값이 나온다.(계산 결과가 허용 범위를 초과할 때 발생하는 오류)   
* 정확하게 계산해야할 때는 실수 타입을 사용하지 않는 것이 좋다.   
* 정수 타입을 0으로 나눌 수 없다.(/,%) -> ArithmeticException 예외 발생   
* 실수 타입인 0.0으로 나눌 때 
> / 0.0 -> Infinity(무한대)   
> %(나눈 나머지) 0.0 -> NaN(Not a Number)   
-> 이 값들로 연산하면 그 결과도 Infinity나 NaN이 나온다.   
* Infinity 인지 NaN인지 확인하려면 -> Double.isInfinite(), Double.isNaN()메소드를 사용. 맞으면 true 반환.   
* == 사용시 주의할 점 -> 0.1f == 0.1의 경우 false가 나온다. 0.1f는 0.1의 근사값으로 표현되어 0.1보다 조금 큰 값이 되어버린다.    
-> 모두 float 타입으로 강제 타입 변환 후 비교 연산을 하던지 정수로 변환해서 비교하면 된다.   
* String의 경우는 ==가 아닌 .equals()메소드를 사용해야한다. ( String은 참조 타입. 문자열 리터럴이 동일하다면 동일한 String 객체를 참조한다. -> 리터럴이 같으면 같은 주소값을 가진다.)
 이 때 new로 새로운 String 객체를 만들경우 그 안의 값이 같더라도 다른 주소값을 가진다. == 연산자는 변수에 저장된 값만 비교하기 때문에 리터럴이 같아도 저장된 주소값이 다르면 false가 뜬다.
 .equals()메소드는 문자열 값이 동일한지 비교한 후 boolean값을 반환한다.   
 * 삼항 연산자 -> 조건식 ? 참일 경우 반환값 : 거짓일 경우 반환값




