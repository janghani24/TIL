## REST
> REpresentational State Transfer의 약자. 네트워크상에서 클라이언트와 서버 사이의 통신을 구현하는 방법 중 하나.   
> 클라이언트가 서버에 요청을 보냄. => 서버가 응답으로 보내주는 Resource(자원)의 상태를 Representation이라고 함.   
> 하나의 Resource는 여러 형태의 Representation으로 전달 할 수 있다. (주로 JSON)  
> 원래 웹(HTTP)의 기본 응답이 HTML인데 이를 JSON 등 다른 규격으로 사용하는 것으로 접근. => 웹을 브라우저 서비스가 아닌 데이터를 주고받는 API서비스의 형태로 발전.   
> 장점 : 안정적이고 검증된 웹 기술을 그대로 사용가능. (서버 프로그램으로 자바, 서블릿등 사용가능. 서버 솔루션과 여러 인프라 재활용 가능.)

* JSON : JavaScript Object Notation의 약자. 그 자체로 자바스크립트 객체 구조를 가지고있어 웹 브라우저에서 바로 처리 가능하다.

* RESTful : REST원칙을 따르는 시스템. REST자체는 특정 언어나 컨테이너를 요구하지 x. 다양한 언어와 서버 소프트웨어를 통해 구현할 수 있다.

* 클라이언트가 요청을 보냄 => URI/URL을 이용. 서버에 HTTP규격에 따라 요청. => 처리 결과는 보통 JSON규격 사용. => 웹에서 응답받은 데이터를 웹의 화면 처리에 사용.

* URI : 특정 리소스를 식별하는 통합 자원 식별자. 
* URL : 네트워크 상에서 자원이 어디 있는지를 알려주기 위한 규약. URI에 포함된다. 
=> URI는 식별자. URL은 위치를 가르쳐준다고 이해.

* 스프링 프레임워크 사용시 @RestController사용으로 구현가능.

* REST API 설계원칙
> 동사 대신 명사 사용(ex. getProductList보다 products같은 명사 형태가 적합.)   
> 상태 변경 시 GET메서드와 쿼리 파라미터 사용금지.   
> : 수정, 삭제와 같이 데이터의 상태를 변경하는 경우 파라미터 형태가 아닌 HTTP메서드와 경로 파라미터로 처리.    
> ex ) GET / api / products?action=delete&id=1021 보다는 DELETE / api / products / 1021   
> 복수 명사 사용 (product보단 products)
> 관계 형태 표현에 하위 리소스 사용
> 에러 정보 제공   
> : 에러 발생 시 여러 HTTP상태 코드를 활용해야하며 별도의 에러 정보를 응답 메시지 구조에 포함 할 수 있어야 한다.


<hr>

## 구현 문제
### 상하좌우
* N x N크기의 정사각형 공간. 1 x 1크기의 정사각형으로 나누어져있다. 가장 왼쪽 위 좌표는 (1,1) 가장 오른쪽 아래는 (N,N)
 항상 시작은 (1,1)
 L : 왼쪽으로 한칸   
 R : 오른쪽으로 한칸   
 U : 위로 한칸   
 D : 아래로 한칸   
 최종으로 도착하는 칸의 좌표
 
 입력 조건   
 첫째 줄에 공간의 코기를 나타내는 N이 주어진다. (1<=N<=100)   
 둘째 줄에 여행가 A가 이동할 계획서 내용이 주어진다. (1<=이동횟수<=100)   
 
 출력 조건   
 첫째 줄에 여행가 A가 최종적으로 도착할 지점의 좌표 (X,Y)를 공백으로 구분하여 출력

 범위외로의 이동은 무효
 
 해설   
 좌표로 나타낼 때 오른쪽 => (0,1) 을 더해준다. 위 => (-1,0)을 더해줌 (오른쪽으로 갈 수록 y가 늘어나는 공간)등 좌표로 표현이 가능하다.
 ```python
 # N을 입력받기
 n = int(input())
 x, y = 1, 1
 plans = input().split() # LRUD등
 
 # L, R, U, D에 따른 이동 방향
 dx = [0,0,-1,1]
 dy = [-1,1,0,0]
 move_types = ['L','R','U','D']
 
 # 이동 계획을 하나씩 확인
 for plan in plans:
   #이동 후 좌표 구하기
   for i in range(len(move_types)):
     if plan == move_types[i]:
     nx = x + dx[i] # 해당 move_types에 따른 좌표를 더해줌
     ny = y + dy[i]
 # 공간을 벗어나는 경우 무시
 if nx < 1 or ny < 1 or nx > n of ny > n:
    continue
 #이동 수행
 x, y = nx, ny
 
 print(x,y)
