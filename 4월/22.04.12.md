# 알고리즘
* 이것이 취업을 위한 코딩테스트다 with 파이썬 책 참고.  
* 주로 사용했던 언어는 JAVA지만 파이썬도 기초는 알고있어서 코테용이지만 알고리즘 공부에 도움이 될것같아 시작.

## 그리디
> '탐욕법'이라고도함.  
> '현재 상황에서 지금 당장 좋은 것만 고르는 방법'

```python
# 큰 수의 법칙

주어진 수 들을 M번 더하여 가장 큰 수를 만든다. 단 특정 인덱스에 해당하는 수가 연속으로 K번 더해질 수는 없다.

# 입력조건   
# 첫째 줄에 N(2<=N<=1000), M(1<=M<=10000), K(1<=K<=10000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.  
# 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1 이상 10000 이하의 수로 주어진다.
# 입력으로 주어지는 K는 항상 M보다 작거나 같다.  

# 해결과정  
# M번 반복해서 가장 큰 수를 더하고 두번째로 큰 수를 한번 더한 후, 다시 가장 큰 수를 M번 더하는 과정을 반복한다.
# 예를 들어 M이 8이고 K가 2일 경우, 가장 큰 수를 A, 두번째로 큰 수를 B라고 했을 때,
# A + A + B + A + A + B + A + A 이 된다.
# 이 때 A + A + B 가 한세트가 되어 반복된다는걸 알 수 있다.
# 가장 큰수가 더해지는 횟수는 M / (K+1) * K + M % (K+1)이 된다. // 한세트는 K+1개. 총횟수를 한세트의 수로 나누고 나누어 떠어지지않은 나머지를 더해준다.

#N,M,K를 공백으로 구분하여 입력받기
n,m,k = map(int,input().split())
#N개의 수를 공백으로 구분하여 입력받기
data = list(map(int,input().split()))

data.sort() # 입력받은 수 정렬
first = data[n-1] # 가장 큰 수
second = data[n-2] # 두번째로 큰 수

# 가장 큰 수가 더해지는 횟수 계산
count = int(m/(k+1))*k
count += m%(k+1) # 한세트로 나누어떨어지지않은 횟수

result = 0
result += (count) * first
result += (m-count) * second # 전체횟수 m에서 가장 큰 수의 횟수인 count를 뺏으므로 두번째로 작은 수의 횟수가 나온다.

print(result) # 답
```
* 알고리즘을 처음 공부해봤는데 수학을 하는것같아 매우 재미있었다. 문제 해결 능력도 매우 중요하고 그 답안을 코드로 구현하는 과정이 까다롭다고 느꼈다. 다양한 방법으로 구현가능한데 그 중에서 가장 클린하고 효율적인 코드를 작성하는 것을 목표로 공부해야할듯하다.
